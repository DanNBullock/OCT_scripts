function analyzeSubjectOCTDataWrapper(inputSubjectDir,outputSubjectDir,centroidFiles ,visFieldDiameterLimit, retinaMeanToggle,smoothParam,threshFloor)
%analyzeOCTDataWrapper(inputSubjectDir,outputSubjectDir,centroidCSVPath,visFieldDiameterLimit, retinaMeanToggle)
%
%This function analyses a single subject's output files generated by
%createCSVsumOutputFiles and parseCsvExport.  Iteratively, by degrees of
%visual angle, takes the mean and standard deviation of the relevant
%sections of the retina.  Saves down a per subject CSV output.
%
%  INPUTS
%
%  inputSubjectDir:  output directory from
%  createLayerAmalgumOutputs.  Only files contained here
%  should be the relevant CSVs
%
%  outputSubjectDir:  the directory to save down the output from these
%  analyses.  If not specified will create ('subjectLayerAnalyses')
%  sub-directory directory in <inputSubjectDir>
%
%  centroidFiles:  cell array containing relevant centroid csv *file
%  paths*.  Shouldn't matter what order they are in.
%
%  visFieldDiameterLimit:  Even integer value (under the assumption of
%  symetric visual field measurement with an integer radidus measure)
%  assumed, will throw error otherwise.  This input designates the maximum visual
%  field diameter that should be computed across analyses.  Specified to
%  preemptively control for intersubject variance resulting from centroid
%  displacement in <createCSVsumOutputFiles/parseCsvExport> output data
%  arrays(?).
%
%  retinaMeanToggle:  either "rings" or "full".  This indicates whether the
%  mean of the visual field should be computed as hollow, cocentric, 1mm
%  rings (think dart board) or as a full circle/elipsoid.
%
%  smoothParam:  smoothing kernel to apply to <subjectLayersCSVpath> data.
%  If variable is empty, no smoothing is applied.
%
%  threshFloor:  floor threshold value for data in <subjectLayersCSVpath>
%  data.  Values below floor are set to NaN and not computed in averages.

%
%  OUTPUTS:
%
%  none, saves down the output
%
% Adapted from code produced by Dan Bullock and Jasleen Jolley 05 Nov 2019
% Dan Bullock 22 Jan 2020
%% Subfunctions
% 
% iteratedCentroidMeanCompute.m
%
% 
%
%% Begin Code
% initialize variables and perform checks

% set output directory to subdirectory of <subjDataDir> if it isn't defined, 
if isempty(outputSubjectDir)
    outputSubjectDir=fullfile(inputSubjectDir,'subjectLayerAnalyses');
else
    %do nothing
end

%create output directory if it doesnt exist
if ~isfolder(outputSubjectDir)
    mkdir(outputSubjectDir);
else
    %do nothing
end

if isempty(visFieldDiameterLimit)
    fprintf('\n visFieldDiameter not set, computing maximum available')
else
    if rem(visFieldDiameterLimit,2)==0 %iseven
    visFieldRadiusLimit=visFieldDiameterLimit/2;
    else %isodd
    error('\n input visFieldDiameterLimit is not even')
    end
end

if isempty(retinaMeanToggle)
    fprintf('\n retinaMeanToggle not set, computing means as hollow, cocentric, 1mm rings')
    retinaMeanToggle='rings';
else
    %do nothing
end

%%  Begin parsing of file names 
% overall this is setting the foveal point, known as the centroid here. Need to
% read the slice and position information from Heidelberg and add into the
% centroid table.

inputDirContents = dir(inputSubjectDir);
inputFileNames = {inputDirContents(~[inputDirContents(:).isdir]).name};

%reading in the files, generating the paths to serve as analysis targets
for iInputFiles=1:length(inputFileNames)
    currentFileName=inputFileNames{iInputFiles};
    %finding the indexes of underscores, just as before
    underscoreIndexes=strfind(currentFileName,'_');
    %here we are finding the last part of the file name.  Theoretically, we
    %could have used the outputs of the function fileparts on the full file
    %path for each file in <primaryOutputDir>
    dotIndexes=strfind(currentFileName,'.');

    %working under assumption that second name component is eye
    inputEye{iInputFiles}=currentFileName(1:underscoreIndexes(1)-1);
    %working under assumption that third and last (it makes both
    %assumptions) name component is analysis
    inputLayerAnalyses{iInputFiles}=currentFileName(underscoreIndexes(1)+1:dotIndexes-1);
end %end analyis target path generation iteration

%Create unique subject/eye stems
%remove .csv
allFileNamesinput=erase(inputFileNames,'.csv');

% %centroid dir contents
% centroidDirContent=dir(centroidDataDir);
% centroidDirNames={centroidDirContent.name};
% centroidFiles=centroidDirNames(contains(centroidDirNames,'centroid'));

%% Begin analysis computations


%establish the output objects
sortedMaskedMean=zeros(length(inputFileNames),[visFieldDiameterLimit/2]);
sortedmaskedStd=zeros(length(inputFileNames),[visFieldDiameterLimit/2]);

for iAnalysis=1:length(inputFileNames)  %loop over input files
    
    %load correct centroid file
    centroidFileIndex=contains(centroidFiles,inputEye{iAnalysis});
    currentCentroidFile=centroidFiles{centroidFileIndex};
    centroidCoords= readmatrix(currentCentroidFile);
    
    % set X and Y
    % be careful though because there appears to be a mismatch between our intuitions about x and y and the standard indexing practices of matlab
    currentXVal=centroidCoords(1);
    currentYVal=centroidCoords(2);
    
    % establish empty matricies for sorted output
    %NOTE: this clears the matrix from the last iteration

    
    currentFileName=fullfile(inputSubjectDir,inputFileNames{iAnalysis});
    
    %compute masked means across 1 degree incriments of the input data.
    [maskedMeans,maskedStds] = iteratedCentroidMeanCompute(currentFileName,[currentXVal,currentYVal],visFieldRadiusLimit,retinaMeanToggle,smoothParam,threshFloor);
    
    %store means and std for this analysis iteration
    sortedMaskedMean(iAnalysis,:)=maskedMeans;
    sortedmaskedStd(iAnalysis,:)=maskedStds;
end
    
    %adding the labels as the first column of the cell structure, so that it can function as a table
    meanDataCell=horzcat(allFileNamesinput',num2cell(sortedMaskedMean));
    stdDataCell=horzcat(allFileNamesinput',num2cell(sortedmaskedStd));
    
    %NOTE degreeTotal-1 USED HERE AGAIN FOR CONSISTENCY, this is in keeping with line 183
    varNames=horzcat({'LayerNames'},strcat('degree ',strsplit(num2str(1:visFieldRadiusLimit),' ')));
    
    % create results tables
    meanDataTable=cell2table(meanDataCell,'VariableNames',varNames);
    stdDataTable=cell2table(stdDataCell,'VariableNames',varNames);
    
    %nothing complicated for naming conventions
    meanTableName='meanTable.csv';
    stdTableName='stdTable.csv';
    
    %writes them as table
    writetable(meanDataTable,fullfile(outputSubjectDir,meanTableName))
    writetable(stdDataTable,fullfile(outputSubjectDir,stdTableName))
    

end